\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage[hidelinks]{hyperref}
\usepackage{titlesec}
\usepackage{tocloft}
\usepackage[german]{babel}
\usepackage{datetime}
\usepackage{graphicx} 
\usepackage{xcolor}
\usepackage{comment}
\usepackage{setspace}
\onehalfspacing
\usepackage{enumitem}
\renewcommand{\arraystretch}{2}
\usepackage[backend=biber,style=alphabetic,hyperref=true]{biblatex}
\usepackage{xurl}  % Verbessert URL-Umbrüche
\addbibresource{literatur.bib}  % Bib-Datei einbinden
\usepackage{csquotes}

\renewcommand{\dateseparator}{.} % Setzt das Datumsformat auf TT.MM.JJJJ
\geometry{a4paper, margin=2.5cm}

\begin{document}

%\maketitle
% Deckblatt
\begin{titlepage}
    \begin{flushleft}
        \includegraphics[width=5cm]{logo.png}
    \end{flushleft}

    \vfill

    \begin{center}
        \Huge \textbf{Qualitätssicherungsplan} \\[1.0cm]
        \Large NextGen Development \\[0.5cm]
        \textcolor{gray}{\rule{0.8\textwidth}{0.4pt}} \\[0.5cm]
        \textbf{Version 1.0} \\[0.5cm] %BITTE NACH ÄNDERUNGEN ANPASSEN!
        \large \today \\[1.5cm]
    \end{center}

    \vfill

    \noindent
    \begin{minipage}[t]{0.45\textwidth}
        \textbf{Teammitglieder:}\\
        Julian Lachenmaier\\
        Ayo Adeniyi\\
        Din Alomerovic\\
        Cedric Balzer\\
        Rebecca Niklaus\\
    \end{minipage}%
    \hspace{1cm}
    \begin{minipage}[t]{0.45\textwidth}
        \textbf{Verantwortlich für dieses Dokument:}\\
        Rebecca Niklaus (Qualitätssicherung)\\
    \end{minipage}

\end{titlepage}

\tableofcontents
\newpage

\section{Einleitung}
Die Qualitätssicherung spielt eine zentrale Rolle im gesamten Projektverlauf. Dadurch soll sichergestellt werden, dass alle Ergebnisse den definierten Anforderungen entsprechen. Dieser Qualitätssicherungsplan beschreibt die Maßnahmen, Prozesse und Standards, die angewendet werden, um eine hohe Qualität der Software sowie der zugehörigen Dokumentation zu gewährleisten.

Der Plan umfasst verschiedene Aspekte der Qualitätssicherung, darunter das Projektmanagement, die Einhaltung von Coding-Standards, Versionierung, Teststrategien sowie die Dokumentation. Durch die Implementierung bewährter Methoden und den Einsatz geeigneter Tools wird sichergestellt, dass das Endprodukt nicht nur funktional, sondern auch stabil, wartbar und benutzerfreundlich ist.

Darüber hinaus legt dieser Plan die Verantwortlichkeiten innerhalb des Teams fest und beschreibt, wie Qualitätssicherungsmaßnahmen kontinuierlich überwacht und verbessert werden. Ziel ist es, potenzielle Fehler frühzeitig zu erkennen, Risiken zu minimieren und eine transparente sowie effiziente Zusammenarbeit zu fördern.

\newpage
\section{Projektmanagement}
Ziel des Projektmanagements ist, Risiken zu begrenzen und Projektziele unter Verwendung der verfügbaren Ressourcen zu erreichen. Das Endergebnis des Projekts soll den Anforderungen des Kunden entsprechen. Im folgenden Abschnitt werden Maßnahmen definiert, um dieses auf Seiten des Projektmanagements zu erreichen.

Um einen organisierten Projektablauf zu gewährleisten, werden häufig Methoden wie Scrum oder Kanban verwendet. Dieses Projekt orientiert sich an der Kanban-Vorgehensweise.

Kanban ist eine agile Methode. Das heißt, dass man die Arbeitsweise im Laufe des Projekts durch kleine Änderungen laufend verbessert \cite{dechange_agiles_2024}. Zur Visualisierung der Aufgaben des Teams wird ein Kanban-Board verwendet. Diese werden in drei Zustände unterteilt: To-Do, in Bearbeitung und vollständig. Für die Projektplanung wird das Tool \textbf{ClickUp} verwendet.

\subsection{Ressourcen-Planung} Für die Bearbeitung eines Projekts stehen begrenzte Ressourcen zur Verfügung. Im Rahmen dieses Projekts sind Personal- und zeitliche Ressourcen relevant.

Das Zeitmanagement stellt sicher, dass Abgabefristen eingehalten werden können \cite{helmold_projektmanagement_2023}. Jedem der fünf Projektmitglieder steht wöchentlich 10 Stunden zur Verfügung. Um diese möglichst sinnvoll zu nutzen, wird die Aufgabenverteilung auf die Fähigkeiten und Erfahrungen der Mitglieder angepasst. Die Zeiterfassung erfolgt in ClickUp.

\subsection{Projektphasen und Meilensteine} Das Projekt wird in mehrere Phasen unterteilt, um eine strukturierte Vorgehensweise sicherzustellen. Jeder Phase sind klare Meilensteine zugewiesen, um den Fortschritt messbar zu machen und um sicherzustellen, dass Deadlines eingehalten werden können. Die Meilensteine sind im Projektplan festgelegt.

\subsection{Kommunikationsmanagement} Grundvorraussetzung für einen erfolgreichen Projektablauf stellt die Zusammenarbeit und das Wohlbefinden der einzelnen Mitglieder dar. Sollten sich Mitglieder über- oder unterfordert fühlen, soll dies direkt kommuniziert werden können. Daher werden zwei Teams-Meetings á 15 Minuten pro Woche fest eingeplant, um mögliche Engpässe frühzeitig zu beheben. Außerdem besteht jederzeit die Möglichkeit, sich über Teams oder WhatsApp an sein Team zu wenden.

\subsection{Risikomanagement} Bereits zu Beginn des Projekts werden mögliche Risiken, die im Laufe des Projekts zu Problemen führen können, analysiert. Im Bereich des Projektmanagements werden hierbei insbesondere Risiken genannt, die sich auf einen Ressourcen-Mangel beziehen. Daher wird eine Risikoanalyse durchgeführt, um präventive Maßnahmen vor Beginn des Projekts zu definieren und um auf mögliche Komplikationen vorbereitet zu sein.

\newpage
\section{Software-Qualität}
Software-Qualität bezieht sich auf die Gesamtheit von Merkmalen und Eigenschaften, die sicherstellen, dass die Software die Anforderungen erfüllt sowie stabil und wartbar bleibt. Ein wichtiger Punkt ist die Verwaltung des Codes, die durch die Nutzung gewisser Verfahren und Tools erreicht wird. Die umfasst sowohl die Versionskontrolle als auch die Beachtung der Code-Qualität.

\subsection{Versionskontrolle}
n der Versionskontrolle wird GitHub als Plattform genutzt, um den effektiv zu verwalten und Änderungen nachvollziehen zu können. Das Hauptziel dabei ist, eine klare und strukturierte Entwicklung zu gewährleisten, um die Codequalität zu maximieren. Dabei sind folgende Punkte zu beachten:

\begin{itemize}
    \item \textbf{Branching-Modell:} Ein effektives Branching-Modell ist entscheidend, um parallel an verschiedenen Funktionen und Fixes arbeiten zu können, ohne die Entwicklung anderer Bereiche zu stören. Ein gängiges Modell ist das Git-Flow-Modell oder eine angepasste Version davon. Der Hauptbranch enthält immer die Version des Codes, die produktionsbereit ist. Für jedes neue Feature oder für Bug-Fixes wird ein eigener Branch erstellt. Nach der Fertigstellung und einer Überprüfung der Code-Qualität wird dieser in den Hauptbranch gemerged.
    \item \textbf{Pull-Requests und Code-Reviews:} Bevor Codeänderungen in den Hauptbranch gemerged werden, muss eine Pull-Request durchgeführt werden. So wird sichergestellt, dass der Code den Qualitätsstandards entspricht und keine bestehenden Funktionen beinträchtigt werden.
    \item \textbf{Merge-Requests:} Bevor eine Merge-Request akzeptiert werden kann, müssen alle Tests bestanden werden. Dadurch wird sichergestellt, dass nur getesteter Code in den Hauptbranch gelangt.
\end{itemize}

Durch die Anwendung dieser Prozesse wird die Codequalität durchgehend überwacht und verbessert, während parallel die Flexibilität und Effizienz bei der Entwicklung neuer Features erhalten bleibt.

\subsection{Code-Qualität}
Durch einheitliche Konfigurationen und Best Practices wird sichergestellt, dass der Code gut strukturiert, wartbar und fehlerfrei bleibt. Dafür werden folgende Ansätze und Werkzeuge verwendet:

\begin{itemize}
    \item \textbf{Einheitliche Konfigurationen für IDEs}: Eine Nutzung einheitlicher Versionen ist essenziell, um Code-Konflikte zu vermeiden. Für \mbox{ASP.NET} wird hierbei die Version 8.0 verwendet, für React Version 19. So wird sichergestellt, dass keine Inkompatibilitäten auftreten.
    \item \textbf{Best Practices:} Außerdem sollen Best Practices genutzt werden, um eine gute Code-Qualität sicherzustellen. In React wird hierbei ESLint verwendet. ESLint ist ein Tool zur Analyse von JavaScript-Code, das Probleme findet, um Code konsistenter und fehlerfreier zu machen. Viele Probleme können automatisch behoben werden \cite{eslint_find_2025}. In .NET sind standardmäßig Roslyn Analyzers enthalten. Für eine umfassende Codeanalyse empfiehlt es sich, die integrierten Roslyn Analyzers mit StyleCop.Analyzers zu kombinieren, da Roslyn grundlegende Fehler und Warnungen erkennt, während StyleCop zusätzlich für konsistente Code-Stil- und Formatierungsrichtlinien sorgt.
\end{itemize}

\newpage
\section{Textkonzept}
Mithilfe von Tests werden Bugs gefunden, die im Laufe der Entwicklung auftreten können. Durch sie wird ermittelt, ob ein Programm so funktioniert, wie es gedacht ist \cite{eichstadt_testen_2024}.

\subsection{Testarten}
Es kann zwischen folgenden Testarten unterschieden werden \cite{eichstadt_testen_2024}:
\begin{itemize}
    \item \textbf{Manuelles Testen:} Tests werden ohne Automatisierung von festgelegten Testern durchgeführt. Dies wird häufig für UI/UX-Tests, visuelle Überprüfungen und Interaktionstests im Frontend genutzt.
    \item \textbf{Unit-Test:} Testet einzelne Funktionen oder Module, z. B. die Prüfung einer E-Mail-Adresse auf Gültigkeit. Dies wird hauptsächlich im Backend angewendet.
    \item \textbf{Integrationstest:} Überprüft das Zusammenspiel verschiedener Module, um sicherzustellen, dass sie korrekt zusammenarbeiten. Da Frontend und Backend mithilfe von API-Calls interagieren, betrifft dieser Test beide Bereiche.
    \item \textbf{Systemtest:} Testet das gesamte System, einschließlich Benutzeroberfläche und Programmlogik. Dieser Test kann sowohl das Frontend als auch das Backend betreffen.
    \item \textbf{Akzeptanztest:} Der letzte Test vor der Auslieferung, um sicherzustellen, dass die Software alle Anforderungen erfüllt. Dieser kann sowohl das Frontend als auch das Backend abdecken.
    \item \textbf{Regressionstest:} Wiederholung früherer Tests, um sicherzustellen, dass Änderungen keine bestehenden Funktionen beeinträchtigen. Diese Art von Test betrifft sowohl Frontend als auch Backend.
\end{itemize}

\subsection{Fehlerarten}
Des Weiteren kann zwischen folgenden Fehlerarten unterschieden werden, für deren Überprüfung verschiedene Testarten benötigt werden \cite{eichstadt_testen_2024}:
\begin{itemize}
    \item \textbf{Funktionale Fehler:} Diese treten auf, wenn eine Funktion nicht wie vorgesehen arbeitet, beispielsweise ein nicht funktionierender Link auf einer Webseite. Solche Fehler lassen sich in der Regel gut durch automatisierte Tests, wie Unit- oder Integrationstests, aufdecken.
    \item \textbf{Inhaltliche Fehler:} Hierbei handelt es sich um Fehler im Text oder in der Darstellung von Inhalten, etwa Rechtschreibfehler oder falsche Bilder in einem Artikel. Während einige dieser Fehler durch automatisierte Tools (z. B. Rechtschreibprüfungen) erkannt werden können, erfordert die inhaltliche Prüfung in den meisten Fällen manuelle Überprüfung durch einen Tester oder Reviewer.
    \item \textbf{Visuelle Fehler:} Diese entstehen, wenn beispielsweise ein Fenster einer Webseite einen anderen Bereich überdeckt oder eine Darstellung fehlerhaft ist. Automatisierte visuelle Regressionstests können solche Probleme erkennen, dennoch ist oft eine manuelle Sichtprüfung notwendig, um subtile Designfehler auszumachen.
    \item \textbf{Benutzerfreundlichkeitsfehler:} Solche Fehler betreffen die Usability, etwa wenn eine Benutzerführung unnötig kompliziert oder nicht intuitiv gestaltet ist. Diese Art von Fehler lässt sich nur bedingt automatisiert testen, da sie stark von subjektiven Nutzereindrücken abhängt. Hier sind manuelle Usability-Tests und Feedback von echten Nutzern essenziell.
\end{itemize}

\subsection{Umsetzung}
Auch die Umsetzung kann unterschiedlich in Angriff genommen werden. Es besteht die Möglichkeit, Black Box Testing, White Box Testing oder Grey Box Testing durchzuführen. Black Box Testing wird aus Benutzersicht durchgeführt, da dort die Software unabhängig vom Quellcode durchgeführt wird. White Box Testing hingegen setzt sich mit dem Kern und Struktur der Anwendung auseinander \cite{gedik_schwarz_2023}. Grey Box Testing stellt eine Mischform aus beiden Testarten dar und bildet einen guten Kompromiss aus Aufwand und Nutzen. Nur kritische Systeme werden als White Box genau betrachtet, nicht so wichtige als Black Box \cite{eichstadt_testen_2024}. Daher erweist sich diese Art des Testens für dieses Projekt als am sinnvollsten.

Für automatisierte Tests werden Tools wie GitHub Actions oder Jenkins verwendet. Nach jedem Push werden verschiedene Prozesse durchlaufen, darunter auch automatisierte Tests. Somit können Regressionstests regelmäßig durchgeführt werden, um nach jeder Änderung überprüfen zu können, ob bereits realisierte Features weiterhin funktionstüchtig sind.

\newpage
\section{Dokumentationskonzept}

Eine strukturierte und umfassende Dokumentation ist unverzichtbar, um die Verständlichkeit, Wartbarkeit und Erweiterbarkeit der Software garantieren zu können. Sie dient als Grundlage für Entwickler, Tester und weitere Stakeholder, um sich effizient in den Code einzuarbeiten. Außerdem sollten Designentscheidungen für den Kunden ersichtlich sein.

Im Projekt werden verschiedene Tools zur Dokumentation eingesetzt. Diese unterstützen sowohl die Code-Dokumentation als auch die Beschreibung der Systemarchitektur und der API-Schnittstellen. Die folgende Tabelle bietet einen Überblick über die eingesetzten Werkzeuge für die Dokumentation in \mbox{ASP.NET} und React.

\begin{table}[h]
    \centering
    \begin{tabular}{|p{4.5cm}|p{4.5cm}|p{4.5cm}|}
        \hline
        \textbf{Framework}                 & \textbf{ASP.NET}        & \textbf{React}                \\ \hline
        \textbf{Code-Kommentare}           & XML-Dokumentation       & JSDoc                         \\ \hline
        \textbf{Automatische Generierung}  & DocFX, Swagger          & Storybook, Styleguidist       \\ \hline
        \textbf{Architektur-Dokumentation} & UML, README, Confluence & README, Komponenten-Diagramme \\ \hline
        \textbf{API-Dokumentation}         & Swagger (OpenAPI)       & OpenAPI für API-Calls         \\ \hline
    \end{tabular}
    \caption{Werkzeuge für die Dokumentation in ASP.NET und React}
    \label{tab:werkzeuge_dokumentation}
\end{table}

\newpage
\section{Dokumente}
Im Laufe des Projekts fallen mehrere Dokumente an, die sowohl zur internen Organisation als auch zur externen Kommunikation mit Betreuern und Kunden dienen. Diese Dokumente unterstützen das Projektmanagement, die Nachverfolgbarkeit von Fortschritten sowie die Qualitätssicherung. Eine klare Struktur und ein einheitlicher Umgang mit diesen Dokumenten sind daher essenziell, um Effizienz, Transparenz und Konsistenz zu gewährleisten.

Je nach Verwendungszweck lassen sich die Dokumente in regelmäßige Berichte sowie dynamische, sich weiterentwickelnde Dokumente unterteilen. Während wöchentliche Abgaben die Projektdokumentation sicherstellen, müssen zentrale Dokumente wie das Lasten- oder Pflichtenheft fortlaufend an veränderte Anforderungen angepasst werden. Die folgenden Abschnitte beschreiben, welche Dokumente erstellt werden müssen und wie der Umgang mit Änderungen organisiert ist.

\subsection{Wöchentliche Abgabe}
Wöchentlich abzugeben sind folgende Dokumente:
\begin{itemize}
    \item \textbf{Wochenbericht:} Wöchentlich muss ein Wochenstatusbericht eingereicht werden, in dem die bearbeiteten Aufgaben reflektiert werden sollen. Des Weiteren wird sich auf Abweichungen vom Projektplan bezogen, um die Gestaltung der folgendenen Wochen dementsprechend anpassen zu können. Dafür wurde ein Template in Word erstellt, das in ClickUp hinterlegt wurde.
    \item \textbf{Aufwandsbericht:} Ebenfalls wöchentlich einzureichen ist der Aufwandsbericht. Dieser entnimmt die aufgewendete Zeit der Projektmitglieder aus ClickUp und summiert diese. Außerdem soll die insgesamt aufgewendete Zeit berechnet werden. Dies erfolgt in Excel und wird als PDF eingereicht.
\end{itemize}

\subsection{Umgang mit sich weiterentwickelnden Dokumenten}
Dokumente wie das Lasten- oder Pflichtenheft werden im Projektverlauf häufig an sich ändernde Anforderungen angepasst. Dies stellt sicher, dass Änderungen klar nachvollzogen werden können. Dabei sollten folgende Punkte beachtet werden:
\begin{itemize}
    \item \textbf{Versionierung}: Jede Dokumentenänderung wird mit einer neuen Versionsnummer versehen. Dies stellt sicher, dass Änderungen klar nachvollzogen werden können, was sowohl aus Kunden- als auch Entwicklersicht relevant ist.
    \item \textbf{Historisierung}: Ältere Versionen bleiben zur Nachverfolgbarkeit erhalten und sollten weiterhin zur Verfügung stehen. Dies erfolgt über die frei zugängliche Website des Teams.
    \item \textbf{Regelmäßige Reviews}: Um eine hohe Qualität und Konsistenz sicherzustellen, sollten Dokumente regelmäßig überprüft und aktualisiert werden. Hierbei wird überprüft, ob gewisse Standards oder Vorgaben eingehalten werden. Dies erfolgt durch definierte Reviewer, die nach dem Vier-Augen-Prinzip oder in Form von Peer Reviews arbeiten \cite{studysmarter_dokumentationsreview_nodate}.
\end{itemize}

\newpage
\section{Fazit}
Die Qualitätssicherung ist ein essenzieller Bestandteil des Projekts, um die Einhaltung aller Anforderungen zu sichern um das Endprodukt zuverlässig, wartbar und benutzerfreundlich zu gestalten. Durch strukturierte Prozesse wie Versionierung, Code-Reviews, automatisierte Tests und regelmäßige Dokumentationsupdates wird die Qualität kontinuierlich überwacht und verbessert.

Die Kombination aus bewährten Methoden, modernen Tools und einer klaren Kommunikation innerhalb des Teams trägt dazu bei, Fehler frühzeitig zu identifizieren und die Effizienz der Entwicklung zu steigern. Zudem ermöglicht die regelmäßige Überprüfung der Prozesse eine kontinuierliche Optimierung der Arbeitsweise.

Mit diesem Qualitätssicherungsplan wird eine solide Grundlage für das Team geschaffen, um die Projektziele erfolgreich zu erreichen und ein hochwertiges Produkt zu liefern, das den Anforderungen der Kunden gerecht wird.

\newpage
\printbibliography

\end{document}